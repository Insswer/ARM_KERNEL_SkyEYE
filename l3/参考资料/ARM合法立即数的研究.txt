解析ARM中的合法立即数

ARM中立即数的产生方式：每个立即数由一个8位常数（1~255）循环右移偶数位得到。其中
循环右移的位数由一个4位二级制的两倍表示（0~30）。
有
<immediate>=immed_8循环右移(2*rotate_imm)

这样看来不是每一个立即数都是合法的。
按照该构造方法，一个合法的立即数可能有多种编码方式。如0x3f0就是个合法立即数，它
可以按照下面两种方式进行编码：
immed_8 = 0x3f rotate_imm = 0xe
0011 1111 右移（1110 +1110 = 11100（28））相当于左移4位

或者

immed_8 = 0xfc rotate_imm = 0xf
1111 1010 右移（1111 + 1111 =11110(30))相当于左移两位

由于立即数的构造中包含循环移位操作，循环移位会影响CPSR的进位位C，这样同样的代码，
会出现两种不同的逻辑，这是不允许的。ARM汇编编译器按照下面规则生成立即数：

1.当立即数在 0到0xff范围时，immed_8 = <immediate>,rotate_imm =0
2.其他情况选曲rotate_imm数值最小的编码方式，所以上述例子中前一个是正确的。

一个典型的ARM指令语法格式为
<opcode> {<cond>}{S} <Rd> ,<Rn> {<operand2>}
其中<>为必须，{}为可选
opcode 指令助记符
cond 执行条件
S 是否影响CPSR
Rd 目标寄存器
Rn 第一操作数寄存器
operand2 第二操作数
编码格式如下：
31-28 27-25  24-21   20 19-16 15-12 11-0（12位）
cond   001   opcode  S   Rn     Rd    operand2

对于operand的规定也就是：
当前12位第二操作数来表示一个32位数时，采用将8位数通过
移位的方式来实现，其中12位的低8为放基本数（immed_8)，
而高4位存放循环右移的位数，因为是四位二进制，对应0-15
其的2倍刚好对应0到30

举例：
AND R1，R2，#0x104
当处理器处理第二个操作数0x104时，处理器需要对其进行改造
104
0000 0000 0000 0000 0000 0001 0000 0100
将该数右移2位（左移30位）得到
0000 0000 0000 0000 0000 0000 0100 0001

则8位的operand填入的就是0100 0001 而移位数为15*2=30

结论：
判断原则：
首先看这个数转换为2进制后1的个数是否超过8，如果不超过8，再看这n个1
是否能同时放在8个二进制位中，如果可以，则判断能否通过右移偶数位得到起初被
判断的数，如果可以则满足。。